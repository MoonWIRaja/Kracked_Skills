# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ # SKILL 1: SUPABASE POSTGRES BEST PRACTICES # Scope: Project-wide | File: 01-supabase-postgres.md # ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ ## When to Apply When designing database schemas, writing SQL queries, creating migrations, implementing Row Level Security policies, or optimizing database performance in Supabase projects. ## Row Level Security (RLS) ### Policy Design - Always enable RLS on every table containing user data - Use `auth.uid()` for user identification in policies - Create separate policies for SELECT, INSERT, UPDATE, DELETE - Name policies descriptively: `users_select_own`, `posts_insert_authenticated` - Never use `WITH CHECK (true)` on public tables ### Common Patterns ```sql -- Users can only read their own data CREATE POLICY "users_select_own" ON users FOR SELECT USING (auth.uid() = id); -- Authenticated users can insert with their own ID CREATE POLICY "posts_insert_authenticated" ON posts FOR INSERT WITH CHECK (auth.uid() = user_id); -- Users can update their own records CREATE POLICY "profiles_update_own" ON profiles FOR UPDATE USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id); ``` ## Security Antipatterns to Avoid - `USING (true)` on sensitive tables - Missing `WITH CHECK` on INSERT/UPDATE policies - Forgetting to enable RLS after creating table - Using `service_role` key in client-side code ## Indexing Strategy ### When to Create Indexes - Foreign key columns (always) - Columns used in WHERE clauses frequently - Columns used in ORDER BY clauses - Columns used in JOIN conditions ### Index Types - B-tree (default): equality and range queries - GIN: JSONB, arrays, full-text search - GiST: geometric data, full-text search ### Index Best Practices ```sql -- Composite index for common query patterns CREATE INDEX idx_posts_user_created ON posts(user_id, created_at DESC); -- Partial index for filtered queries CREATE INDEX idx_orders_pending ON orders(created_at) WHERE status = 'pending'; -- GIN index for JSONB queries CREATE INDEX idx_products_metadata ON products USING GIN(metadata); ``` ## Query Optimization ### Efficient Patterns - Select only needed columns, never `SELECT *` - Use `LIMIT` with pagination, prefer cursor-based over offset - Use `EXISTS` instead of `COUNT(*)` for existence checks - Batch inserts with `INSERT INTO ... VALUES (...), (...), (...)` ## Avoid N+1 Queries ```typescript // Bad: N+1 query pattern const users = await supabase.from('users').select('*'); for (const user of users.data) { const posts = await supabase.from('posts').select('*').eq('user_id', user.id); } // Good: Single query with join const usersWithPosts = await supabase .from('users') .select('*, posts(*)'); ``` ## Supabase-Specific Patterns ### Realtime Subscriptions - Subscribe only to necessary columns - Use filters to reduce payload size - Always unsubscribe on component unmount ### Edge Functions - Keep cold start time low (<50ms) - Use connection pooling for database access - Cache frequently accessed data ### Storage - Use signed URLs for private files - Set appropriate cache-control headers - Implement file size limits on upload